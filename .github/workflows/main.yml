name: Kotlin Dependency License Check

on:
  push:
    branches:
      - master

jobs:
  check-licenses:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Check for TOML files
        id: check_toml
        run: |
          if find . -type f -name "*.toml" -print -quit; then
            echo "toml_files_found=true" >> "$GITHUB_OUTPUT"
          else
            echo "toml_files_found=false" >> "$GITHUB_OUTPUT"
          fi

      # Steps to set up Go and build the license checker (only if TOML files are found)
      - name: Determine latest Go version
        if: steps.check_toml.outputs.toml_files_found == 'true'
        id: get_go_version
        run: |
          latest_go_version=$(curl -s https://go.dev/VERSION?m=text | sed 's/^go//' | head -n 1)
          echo "go-version=$latest_go_version" >> "$GITHUB_OUTPUT"

      - name: Set up Go
        if: steps.check_toml.outputs.toml_files_found == 'true'
        uses: actions/setup-go@v4
        with:
          go-version: ${{ steps.get_go_version.outputs.go-version }}

      - name: Create license checker directory
        if: steps.check_toml.outputs.toml_files_found == 'true'
        run: mkdir -p license-checker

      - name: Build and run license checker
        if: steps.check_toml.outputs.toml_files_found == 'true'
        shell: bash
        run: |
          # Navigate into the license-checker directory
          cd license-checker

          # Create license-checker.go inside the license-checker directory
          cat <<-'EOF' > license-checker.go
          package main

          import (
            "encoding/xml"
            "fmt"
            "io/fs"
            "io/ioutil"
            "net/http"
            "net/url"
            "os"
            "path/filepath"
            "strings"
            "time"

            "github.com/pelletier/go-toml"
            "github.com/PuerkitoBio/goquery"
          )

          # Structs to parse POM XML
          type MavenPOM struct {
            XMLName    xml.Name  `xml:"project"`
            GroupID    string    `xml:"groupId"`
            ArtifactID string    `xml:"artifactId"`
            Version    string    `xml:"version"`
            Licenses   License   `xml:"licenses>license"`
            Parent     Parent    `xml:"parent"`
          }

          type License struct {
            Name string `xml:"name"`
            URL  string `xml:"url"`
          }

          type Parent struct {
            GroupID    string    `xml:"groupId"`
            ArtifactID string `xml:"artifactId"`
            Version    string `xml:"version"`
          }

          # Fetch POM file from a given URL with retry and redirect handling
          func fetchPOM(url string) ([]byte, error) {
            client := &http.Client{
              Timeout: 10 * time.Second, // Set a timeout
            }

            var data []byte
            var err error

            for attempt := 0; attempt < 3; attempt++ {
              req, _ := http.NewRequest("GET", url, nil)
              resp, err := client.Do(req)
              if err != nil {
                fmt.Printf("Attempt %d: Error fetching POM from %s: %v\n", attempt+1, url, err)
                time.Sleep(time.Duration(attempt+1) * time.Second) // Exponential backoff
                continue
              }
              defer resp.Body.Close()

              if resp.StatusCode == http.StatusOK {
                data, err = ioutil.ReadAll(resp.Body)
                if err != nil {
                  fmt.Printf("Attempt %d: Error reading response body from %s: %v\n", attempt+1, url, err)
                  time.Sleep(time.Duration(attempt+1) * time.Second)
                  continue
                }
                return data, nil
              } else if resp.StatusCode >= 300 && resp.StatusCode < 400 {
                // Handle redirects
                location, err := resp.Location()
                if err != nil {
                  return nil, fmt.Errorf("failed to get redirect location: %v", err)
                }
                url = location.String()
                fmt.Printf("Redirecting to %s\n", url)
                continue // Retry with the new URL
              } else {
                fmt.Printf("Attempt %d: Failed to fetch POM from %s: %s\n", attempt+1, url, resp.Status)
                time.Sleep(time.Duration(attempt+1) * time.Second)
              }
            }

            return nil, fmt.Errorf("failed to fetch POM after retries: %v", err)
          }

          # Parse POM XML data
          func parsePOM(data []byte) (MavenPOM, error) {
            var pom MavenPOM
            err := xml.Unmarshal(data, &pom)
            return pom, err
          }

          # Construct POM URL based on repository base URL and artifact coordinates
          func constructPOMURL(repoBaseURL, groupID, artifactID, version string) string {
            groupPath := strings.ReplaceAll(groupID, ".", "/")
            return fmt.Sprintf("%s/%s/%s/%s/%s-%s.pom", repoBaseURL, groupPath, artifactID, version, artifactID, version)
          }

          # copyleftKeywords contains keywords commonly associated with copyleft licenses
          var copyleftKeywords = []string{
            "gpl", "gnu general public license", "lgpl", "gnu lesser general public license", "agpl", "gnu affero general public license",
            "mozilla public license", "mpl", "common development and distribution license", "cddl", "eclipse public license", "epl",
            "GPL-2.0", "LGPL-3.0", "MPL-2.0", // More specific license names
          }

          # isCopyleft checks if a license name or URL indicates a copyleft license
          func isCopyleft(licenseName, licenseURL string) bool {
            licenseName = strings.ToLower(licenseName)
            licenseURL = strings.ToLower(licenseURL)
            for _, keyword := range copyleftKeywords {
              if strings.Contains(licenseName, keyword) || strings.Contains(licenseURL, keyword) {
                return true
              }
            }
            return false
          }
          # searchOnline performs a web search for the Maven repository
          func searchOnline(groupID, artifactID, version string) (License, error) {
            fmt.Printf("Failed to fetch POM for %s:%s:%s from known repositories. Trying web search...\n", groupID, artifactID, version)
            searchURL := fmt.Sprintf("https://www.google.com/search?q=%s+%s+%s+maven+repository", groupID, artifactID, version)
            doc, err := goquery.NewDocument(searchURL)
            if err != nil {
              return nil, fmt.Errorf("failed to search online: %v", err)
            }

            // Extract the first result URL
            firstResultURL, exists := doc.Find("a").First().Attr("href")
            if !exists || firstResultURL == "" {
              // If no results are found, provide a link to a pre-populated Google search
              searchURL := fmt.Sprintf("https://www.google.com/search?q=%s+%s+%s+maven+repository", groupID, artifactID, version)
              return nil, fmt.Errorf("no results found online. Try searching manually: %s", searchURL)
            }

            // Extract the actual URL from the Google search result link
            if strings.HasPrefix(firstResultURL, "/url?q=") {
              firstResultURL, _ = url.QueryUnescape(firstResultURL[7:strings.Index(firstResultURL, "&")])
            }

            fmt.Printf("Found potential match: %s\n", firstResultURL)

            // Try fetching POM directly from the URL
            pomData, err := fetchPOM(firstResultURL)
            if err != nil {
              return nil, fmt.Errorf("failed to fetch POM from %s: %v", firstResultURL, err)
            }

            pom, err := parsePOM(pomData)
            if err != nil {
              return nil, fmt.Errorf("failed to parse POM from %s: %v", firstResultURL, err)
            }

            return pom.Licenses, nil
          }

          # Retrieve license information for a given artifact
          func retrieveLicenseInfo(groupID, artifactID, version string) (License, error) {
            mavenCentralURL := "https://repo1.maven.org/maven2"
            googleMavenURL := "https://dl.google.com/dl/android/maven2"

            // Attempt to fetch from Maven Central and Google's Maven Repository
            for _, repoURL := range []string{mavenCentralURL, googleMavenURL} {
              url := constructPOMURL(repoURL, groupID, artifactID, version)
              data, err := fetchPOM(url)
              if err == nil {
                pom, err := parsePOM(data)
                if err == nil {
                  // Return licenses if available
                  if len(pom.Licenses) > 0 {
                    return pom.Licenses, nil
                  }

                  // If no licenses found, check parent POM
                  if pom.Parent.GroupID != "" && pom.Parent.ArtifactID != "" && pom.Parent.Version != "" {
                    return retrieveLicenseInfo(pom.Parent.GroupID, pom.Parent.ArtifactID, pom.Parent.Version)
                  }
                }
              }
            }
            return searchOnline(groupID, artifactID, version)
          }
